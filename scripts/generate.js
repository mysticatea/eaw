/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2016 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict"

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const Buffer = require("buffer").Buffer
const fs = require("fs")
const http = require("http")
const path = require("path")

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const UCD_URL = "http://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt"
const FILENAME = path.resolve(__dirname, "../lib/is-narrow-character.js")
const LINE_TERMINATORS = /\r\n|\r|\n|\u2028|\u2029/g
const ROW_PATTERN = /^(\w+)(?:..(\w+))?;(\w+)$/

/**
 * It checks whether the given type is narrow or not.
 *
 * @param {string} type - The type of characters.
 * @returns {boolean} `true` if the type is narrow.
 */
function isNarrow(type) {
    return type === "H" || type === "Na"
}

/**
 * It converts the number to upper case hex string.
 *
 * @param {number} n - The number to convert.
 * @returns {string} The hex string of the number.
 */
function toHex(n) {
    return `0x${n.toString(16).toUpperCase()}`
}

/**
 * It fetches characters information from Unicode Character Database.
 *
 * @returns {Promise<string>} The content of database.
 */
function fetchUnicodeCharacterData() {
    return new Promise((resolve, reject) => {
        http.get(UCD_URL, (res) => {
            const chunks = []

            res.on("data", (chunk) => {
                chunks.push(chunk)
            })
            res.on("end", () => {
                const text = Buffer.concat(chunks).toString("utf8")

                if (res.statusCode === 200) {
                    resolve(text)
                }
                else {
                    reject(new Error(text || "Unknown Error"))
                }
            })
            res.on("error", reject)
        }).on("error", reject)
    })
}

/**
 * It parses the content of Unicode Character Database.
 *
 * @param {string} content - The content to parse.
 * @returns {Array.<{first: number, last: number, type: string}>}
 *  The result of parsing.
 */
function parseUnicodeCharacterData(content) {
    return content.split(LINE_TERMINATORS)
        .map(line => line.replace(/#.+/, "").trim())
        .map(line => {
            const m = ROW_PATTERN.exec(line)
            if (m != null) {
                const first = parseInt(m[1], 16)
                const last = m[2] ? parseInt(m[2], 16) : first
                const type = m[3]

                return {first, last, type}
            }
            return null
        })
        .filter(Boolean)
}

/**
 * It extracts the range of narrow characters.
 *
 * @param {Array.<{first: number, last: number, type: string}>} ranges -
 *  The range of all characters.
 * @returns {Array.<{first: number, last: number}>}
 *  The range of narrow characters.
 */
function extractNarrowRange(ranges) {
    return ranges.reduce((result, range) => {
        if (isNarrow(range.type)) {
            const first = range.first
            const last = range.last

            if (result.length === 0) {
                // 1st range.
                result.push({first, last})
            }
            else {
                // if the range is consecutive with the last range,
                // it merges those.
                const lastRange = result[result.length - 1]
                if (lastRange.last === first - 1) {
                    lastRange.last = last
                }
                else {
                    result.push({first, last})
                }
            }
        }

        return result
    }, [])
}

/**
 * It generates the code which includes `isNarrowCharacter` function.
 *
 * @param {Array.<{first: number, last: number}>} ranges -
 *  The range of narrow characters.
 * @returns {string} The generated code.
 */
function generateCode(ranges) {
    return `/**
 * This code was generated by <../scripts/generate.js>
 */
"use strict"

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------
/*eslint-disable complexity */

/**
 * It checks whether the given character is a narrow character or not.
 *
 * @param {string} character - The character to check.
 * @returns {boolean} \`true\` if the character is a narrow character.
 */
module.exports = function isNarrowCharacter(character) {
    const cp = character.codePointAt(0)
    return (
        ${
            ranges
                .map(range => `(cp >= ${
                    toHex(range.first)
                } && cp <= ${
                    toHex(range.last)
                })`)
                .join(" ||\n        ")
        }
    )
}

/*eslint-enable */
`
}

/**
 * It writes the code to `lib/is-narrow-character.js` file.
 *
 * @param {string} code - The code to write.
 * @returns {Promise<void>} -
 */
function writeFile(code) {
    return new Promise((resolve, reject) => {
        fs.writeFile(FILENAME, code, (err) => {
            if (err == null) {
                resolve()
            }
            else {
                reject(err)
            }
        })
    })
}

//------------------------------------------------------------------------------
// Main
//------------------------------------------------------------------------------

fetchUnicodeCharacterData()
    .then(parseUnicodeCharacterData)
    .then(extractNarrowRange)
    .then(generateCode)
    .then(writeFile)
    .catch(err => {
        console.error(err.stack) //eslint-disable-line no-console
    })
